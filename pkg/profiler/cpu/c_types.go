// Code generated by 'ccgo bpf/cpu/cpu.h -o pkg/profiler/cpu/c_types.go', DO NOT EDIT.

package cpu

import (
	"math"
	"reflect"
	"sync/atomic"
	"unsafe"

	"modernc.org/libc"
	"modernc.org/libc/sys/types"
)

var _ = math.Pi
var _ reflect.Kind
var _ atomic.Value
var _ unsafe.Pointer
var _ *libc.TLS
var _ types.Size_t

// Number of frames to walk per tail call iteration.
// Number of BPF tail calls that will be attempted.
// Maximum number of frames.
// Number of unique stacks.
// Number of items in the stack counts aggregation map.
// Maximum number of processes we are willing to track.
// Binary search iterations for dwarf based stack walking.
// 2^19 can bisect ~524_288 entries.
// Size of the unwind table.
// 250k * sizeof(stack_unwind_row_t) = 2MB

// Unwind tables bigger than can't fit in the remaining space
// of the current shard are broken up into chunks up to `MAX_UNWIND_TABLE_SIZE`.
// Maximum memory mappings per process.

// Values for dwarf expressions.

// Values for the unwind table's CFA type.
// Special values.

// Values for the unwind table's frame pointer type.
// Special values.

// Binary search error codes.

// Stack walking methods.
const ( /* cpu.h:62:1: */
	STACK_WALKING_METHOD_FP    = 0
	STACK_WALKING_METHOD_DWARF = 1
)

type ptrdiff_t = int64 /* <builtin>:3:26 */

type size_t = uint64 /* <builtin>:9:23 */

type wchar_t = int32 /* <builtin>:15:24 */

type s8 = int8    /* basic_types.h:10:14 */
type u8 = uint8   /* basic_types.h:11:14 */
type s16 = int16  /* basic_types.h:12:15 */
type u16 = uint16 /* basic_types.h:13:15 */
type s32 = int32  /* basic_types.h:14:15 */
type u32 = uint32 /* basic_types.h:15:15 */
type s64 = int64  /* basic_types.h:16:15 */
type u64 = uint64 /* basic_types.h:17:15 */

type unwinder_config_t = struct {
	filter_processes uint8
	verbose_logging  uint8
} /* cpu.h:67:1 */

var unwinder_config unwinder_config_t /* cpu.h:70:3: */

type unwinder_stats_t = struct {
	total                                  u64
	success_dwarf                          u64
	error_truncated                        u64
	error_unsupported_expression           u64
	error_unsupported_frame_pointer_action u64
	error_unsupported_cfa_register         u64
	error_catchall                         u64
	error_should_never_happen              u64
	error_pc_not_covered                   u64
	error_jit                              u64
} /* cpu.h:72:1 */

// Unwind tables are splitted in chunks and each chunk
// maps to a range of unwind rows within a shard.
type chunk_info_t = struct {
	low_pc      u64
	high_pc     u64
	shard_index u64
	low_index   u64
	high_index  u64
} /* cpu.h:93:3 */

// Unwind table shards for an executable mapping.
type unwind_info_chunks_t = struct{ chunks [30]chunk_info_t } /* cpu.h:98:3 */

// The addresses of a native stack trace.
type stack_trace_t = struct {
	len       u64
	addresses [127]u64
} /* cpu.h:104:3 */

type stack_count_key_t = struct {
	pid                 int32
	tgid                int32
	user_stack_id       int32
	kernel_stack_id     int32
	user_stack_id_dwarf int32
} /* cpu.h:112:3 */

// Represents an executable mapping.
type mapping_t = struct {
	load_address  u64
	begin         u64
	end           u64
	executable_id u64
	__type        u64
} /* cpu.h:121:3 */

// Executable mappings for a process.
type process_info_t = struct {
	is_jit_compiler u64
	len             u64
	mappings        [250]mapping_t
} /* cpu.h:128:3 */

// State of unwinder such as the registers as well
// as internal data.
type unwind_state_t = struct {
	ip         u64
	sp         u64
	bp         u64
	tail_calls u32
	_          [4]byte
	stack      stack_trace_t
} /* cpu.h:138:3 */

// A row in the stack unwinding table for x86_64.
type stack_unwind_row_t = struct {
	pc         u64
	cfa_type   u8
	rbp_type   u8
	cfa_offset s16
	rbp_offset s16
	_          [2]byte
} /* cpu.h:147:3 */

// Unwinding table representation.
type stack_unwind_table_t = struct{ rows [250000]stack_unwind_row_t } /* cpu.h:152:3 */
